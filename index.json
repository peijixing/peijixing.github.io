[{"categories":["基础知识"],"content":"java的特性和优势 简单性 面向对象 可移植性 高性能 分布性 动态性 多线程 安全性 健壮性 ","date":"2023-02-19","objectID":"/day03.java%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E4%BC%98%E5%8A%BF/:1:0","tags":["java学习"],"title":"Day03.java的特性和优势","uri":"/day03.java%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E4%BC%98%E5%8A%BF/"},{"categories":["基础知识"],"content":"基本命令之跳转 切换盘符： 盘符 + 冒号 ,例【 D: 】 查看目录下的目录和文件 ： dir 切换目录： cd + 位置 ,例【 cd /path 】 /d参数可以使cd命令跨盘符跳转，例【 cd /d E:\\IDE】可以实现跳转到E盘的目录下 相对位置跳转 : cd .. ","date":"2023-02-19","objectID":"/day02.%E5%9F%BA%E6%9C%ACdos%E5%91%BD%E4%BB%A4/:1:0","tags":["java学习"],"title":"Day02.基本DOS命令","uri":"/day02.%E5%9F%BA%E6%9C%ACdos%E5%91%BD%E4%BB%A4/"},{"categories":["基础知识"],"content":"基本命令之功能性命令 清理屏幕 ： cls 退出：exit 查看ip：ipconfig 查看ip和链接信息：ping + ip(或域名) 创建目录：md + 目录名 删除目录： rd + 目录名 创建文件：cd \u003e 文件名 删除文件： del + 文件名 ","date":"2023-02-19","objectID":"/day02.%E5%9F%BA%E6%9C%ACdos%E5%91%BD%E4%BB%A4/:2:0","tags":["java学习"],"title":"Day02.基本DOS命令","uri":"/day02.%E5%9F%BA%E6%9C%ACdos%E5%91%BD%E4%BB%A4/"},{"categories":["基础知识"],"content":"计算机硬件 ","date":"2023-02-19","objectID":"/day01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/:1:0","tags":["java学习"],"title":"Day01.计算机基础","uri":"/day01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"categories":["基础知识"],"content":"冯诺依曼体系结构 ","date":"2023-02-19","objectID":"/day01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/:1:1","tags":["java学习"],"title":"Day01.计算机基础","uri":"/day01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"categories":["基础知识"],"content":"计算机软件 ","date":"2023-02-19","objectID":"/day01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/:2:0","tags":["java学习"],"title":"Day01.计算机基础","uri":"/day01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"categories":["基础知识"],"content":"系统软件 Linux Windows Unix Mac … ","date":"2023-02-19","objectID":"/day01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/:2:1","tags":["java学习"],"title":"Day01.计算机基础","uri":"/day01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"categories":["基础知识"],"content":"应用软件 ","date":"2023-02-19","objectID":"/day01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/:2:2","tags":["java学习"],"title":"Day01.计算机基础","uri":"/day01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"categories":["资源分享"],"content":"阅读 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:1:0","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"主要功能 PS:非常好用的小说阅读器,可以导入网络大神的书源 推荐一波书源 https://oldpei.site/书源.json 自定义书源，自己设置规则，抓取网页数据，规则简单易懂，软件内有规则说明。 列表书架，网格书架自由切换。 书源规则支持搜索及发现，所有找书看书功能全部自定义，找书更方便。 订阅内容,可以订阅想看的任何内容,看你想看 支持替换净化，去除广告替换内容很方便。 支持本地TXT、EPUB阅读，手动浏览，智能扫描。 支持高度自定义阅读界面，切换字体、颜色、背景、行距、段距、加粗、简繁转换等。 支持多种翻页模式，覆盖、仿真、滑动、滚动等。 软件开源，持续优化，无广告。 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:1:1","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"使用说明 官网使用说明 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:1:2","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"下载 github下载地址 |酷安下载地址 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:1:3","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"洛雪音乐助手移动版 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:2:0","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"主要功能 免费使用大多数音乐软件的数据源听音乐 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:2:1","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"使用说明 请低调使用 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:2:2","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"下载 github下载地址 |网盘下载 密码：glqw ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:2:3","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"影音壳子 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:3:0","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"主要功能 影音壳子app是一个由TV Box修改而来的视频播放工具，这里内置了喵TV的视频源，让你可以免费追剧。同时支持手机和电视自适应，不管是在什么端使用，都有着很不错的体验。可以在软件的设置中设置视频源，支持酷云七七、快看影视、小苹果源、利奥影视等等。因为视频源很多，因此不用担心视频播放失效，只要切换一些源就可以了。 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:3:1","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"使用说明 在软件内可以做从提交bug处获取订阅源 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:3:2","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["资源分享"],"content":"下载 下载地址 ","date":"2023-02-08","objectID":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/:3:3","tags":["手机软件"],"title":"自用软件推荐","uri":"/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"categories":["基础知识"],"content":"阅读过 JUC 源码的同学，一定会发现很多并发工具类都调用了一个叫做 Unsafe 的类。 那这个类主要是用来干什么的呢？有什么使用场景呢？这篇文章就带你搞清楚！ ","date":"2023-02-06","objectID":"/unsafe/:0:0","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"Unsafe 介绍 Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 Unsafe 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 Unsafe 的使用一定要慎重。 另外，Unsafe 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 native 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 本地代码。 为什么要使用本地方法呢？ 需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。 对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。 程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。 在 JUC 包的很多并发工具类在实现并发机制时，都调用了本地方法，通过它们打破了 Java 运行时的界限，能够接触到操作系统底层的某些功能。对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。 ","date":"2023-02-06","objectID":"/unsafe/:1:0","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"Unsafe 创建 sun.misc.Unsafe 部分源码如下： public final class Unsafe { // 单例对象 private static final Unsafe theUnsafe; ...... private Unsafe() { } @CallerSensitive public static Unsafe getUnsafe() { Class var0 = Reflection.getCallerClass(); // 仅在引导类加载器`BootstrapClassLoader`加载时才合法 if(!VM.isSystemDomainLoader(var0.getClassLoader())) { throw new SecurityException(\"Unsafe\"); } else { return theUnsafe; } } } Unsafe 类为一单例实现，提供静态方法 getUnsafe 获取 Unsafe实例。这个看上去貌似可以用来获取 Unsafe 实例。但是，当我们直接调用这个静态方法的时候，会抛出 SecurityException 异常： Exception in thread \"main\" java.lang.SecurityException: Unsafe at sun.misc.Unsafe.getUnsafe(Unsafe.java:90) at com.cn.test.GetUnsafeTest.main(GetUnsafeTest.java:12) 为什么 public static 方法无法被直接调用呢？ 这是因为在getUnsafe方法中，会对调用者的classLoader进行检查，判断当前类是否由Bootstrap classLoader加载，如果不是的话那么就会抛出一个SecurityException异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。 为什么要对 Unsafe 类进行这么谨慎的使用限制呢? Unsafe 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。 如若想使用 Unsafe 这个类的话，应该如何获取其实例呢？ 这里介绍两个可行的方案。 1、利用反射获得 Unsafe 类中已经实例化完成的单例对象 theUnsafe 。 private static Unsafe reflectGetUnsafe() { try { Field field = Unsafe.class.getDeclaredField(\"theUnsafe\"); field.setAccessible(true); return (Unsafe) field.get(null); } catch (Exception e) { log.error(e.getMessage(), e); return null; } } 2、从getUnsafe方法的使用限制条件出发，通过 Java 命令行命令-Xbootclasspath/a把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取 Unsafe 实例。 java -Xbootclasspath/a: ${path} // 其中path为调用Unsafe相关方法的类所在jar包路径 ","date":"2023-02-06","objectID":"/unsafe/:2:0","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"Unsafe 功能 概括的来说，Unsafe 类实现功能可以被分为下面 8 类： 内存操作 内存屏障 对象操作 数据操作 CAS 操作 线程调度 Class 操作 系统信息 ","date":"2023-02-06","objectID":"/unsafe/:3:0","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"内存操作 介绍 如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 Unsafe 中，提供的下列接口可以直接进行内存操作： //分配新的本地空间 public native long allocateMemory(long bytes); //重新调整内存空间的大小 public native long reallocateMemory(long address, long bytes); //将内存设置为指定值 public native void setMemory(Object o, long offset, long bytes, byte value); //内存拷贝 public native void copyMemory(Object srcBase, long srcOffset,Object destBase, long destOffset,long bytes); //清除内存 public native void freeMemory(long address); 使用下面的代码进行测试： private void memoryTest() { int size = 4; long addr = unsafe.allocateMemory(size); long addr3 = unsafe.reallocateMemory(addr, size * 2); System.out.println(\"addr: \"+addr); System.out.println(\"addr3: \"+addr3); try { unsafe.setMemory(null,addr ,size,(byte)1); for (int i = 0; i \u003c 2; i++) { unsafe.copyMemory(null,addr,null,addr3+size*i,4); } System.out.println(unsafe.getInt(addr)); System.out.println(unsafe.getLong(addr3)); }finally { unsafe.freeMemory(addr); unsafe.freeMemory(addr3); } } 先看结果输出： addr: 2433733895744 addr3: 2433733894944 16843009 72340172838076673 分析一下运行结果，首先使用allocateMemory方法申请 4 字节长度的内存空间，调用setMemory方法向每个字节写入内容为byte类型的 1，当使用 Unsafe 调用getInt方法时，因为一个int型变量占 4 个字节，会一次性读取 4 个字节，组成一个int的值，对应的十进制结果为 16843009。 你可以通过下图理解这个过程： 在代码中调用reallocateMemory方法重新分配了一块 8 字节长度的内存空间，通过比较addr和addr3可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用copyMemory方法进行了两次内存的拷贝，每次拷贝内存地址addr开始的 4 个字节，分别拷贝到以addr3和addr3+4开始的内存空间上： 拷贝完成后，使用getLong方法一次性读取 8 个字节，得到long类型的值为 72340172838076673。 需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用freeMemory方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在try中执行对内存的操作，最终在finally块中进行内存的释放。 为什么要使用堆外内存？ 对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。 提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。 典型应用 DirectByteBuffer 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。DirectByteBuffer 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。 下图为 DirectByteBuffer 构造函数，创建 DirectByteBuffer 的时候，通过 Unsafe.allocateMemory 分配内存、Unsafe.setMemory 进行内存初始化，而后构建 Cleaner 对象用于跟踪 DirectByteBuffer 对象的垃圾回收，以实现当 DirectByteBuffer 被垃圾回收时，分配的堆外内存一起被释放。 DirectByteBuffer(int cap) { // package-private super(-1, 0, cap, cap); boolean pa = VM.isDirectMemoryPageAligned(); int ps = Bits.pageSize(); long size = Math.max(1L, (long)cap + (pa ? ps : 0)); Bits.reserveMemory(size, cap); long base = 0; try { // 分配内存并返回基地址 base = unsafe.allocateMemory(size); } catch (OutOfMemoryError x) { Bits.unreserveMemory(size, cap); throw x; } // 内存初始化 unsafe.setMemory(base, size, (byte) 0); if (pa \u0026\u0026 (base % ps != 0)) { // Round up to page boundary address = base + ps - (base \u0026 (ps - 1)); } else { address = base; } // 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放 cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); att = null; } ","date":"2023-02-06","objectID":"/unsafe/:3:1","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"内存屏障 介绍 在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（Memory Barrier）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。 在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。 Unsafe 中提供了下面三个内存屏障相关方法： //内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前 public native void loadFence(); //内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前 public native void storeFence(); //内存屏障，禁止load、store操作重排序 public native void fullFence(); 内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以loadFence方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。 看到这估计很多小伙伴们会想到volatile关键字了，如果在字段上添加了volatile关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改flag标志位，注意这里的flag是没有被volatile修饰的： @Getter class ChangeThread implements Runnable{ /**volatile**/ boolean flag=false; @Override public void run() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"subThread change flag to:\" + flag); flag = true; } } 在主线程的while循环中，加入内存屏障，测试是否能够感知到flag的修改变化： public static void main(String[] args){ ChangeThread changeThread = new ChangeThread(); new Thread(changeThread).start(); while (true) { boolean flag = changeThread.isFlag(); unsafe.loadFence(); //加入读内存屏障 if (flag){ System.out.println(\"detected flag changed\"); break; } } System.out.println(\"main thread end\"); } 运行结果： subThread change flag to:false detected flag changed main thread end 而如果删掉上面代码中的loadFence方法，那么主线程将无法感知到flag发生的变化，会一直在while中循环。可以用图来表示上面的过程： 了解 Java 内存模型（JMM）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。 典型应用 在 Java 8 中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 StampedLock 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。 为了解决这个问题，StampedLock 的 validate 方法会通过 Unsafe 的 loadFence 方法加入一个 load 内存屏障。 public boolean validate(long stamp) { U.loadFence(); return (stamp \u0026 SBITS) == (state \u0026 SBITS); } ","date":"2023-02-06","objectID":"/unsafe/:3:2","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"对象操作 介绍 对象属性 对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的putInt、getInt方法外，Unsafe 提供了全部 8 种基础数据类型以及Object的put和get方法，并且所有的put方法都可以越过访问权限，直接修改内存中的数据。阅读 openJDK 源码中的注释发现，基础数据类型和Object的读写稍有不同，基础数据类型是直接操作的属性值（value），而Object的操作则是基于引用值（reference value）。下面是Object的读写方法： //在对象的指定偏移地址获取一个对象引用 public native Object getObject(Object o, long offset); //在对象指定偏移地址写入一个对象引用 public native void putObject(Object o, long offset, Object x); 除了对象属性的普通读写外，Unsafe 还提供了 volatile 读写和有序写入方法。volatile读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和Object类型，以int类型为例： //在对象的指定偏移地址处读取一个int值，支持volatile load语义 public native int getIntVolatile(Object o, long offset); //在对象指定偏移地址处写入一个int，支持volatile store语义 public native void putIntVolatile(Object o, long offset, int x); 相对于普通读写来说，volatile读写具有更高的成本，因为它需要保证可见性和有序性。在执行get操作时，会强制从主存中获取属性值，在使用put方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。 有序写入的方法有以下三个： public native void putOrderedObject(Object o, long offset, Object x); public native void putOrderedInt(Object o, long offset, int x); public native void putOrderedLong(Object o, long offset, long x); 有序写入的成本相对volatile较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念： Load：将主内存中的数据拷贝到处理器的缓存中 Store：将处理器缓存的数据刷新到主内存中 顺序写入与volatile写入的差别在于，在顺序写时加入的内存屏障类型为StoreStore类型，而在volatile写入时加入的内存屏障是StoreLoad类型，如下图所示： 在有序写入方法中，使用的是StoreStore屏障，该屏障确保Store1立刻刷新数据到内存，这一操作先于Store2以及后续的存储指令操作。而在volatile写入中，使用的是StoreLoad屏障，该屏障确保Store1立刻刷新数据到内存，这一操作先于Load2及后续的装载指令，并且，StoreLoad屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。 综上所述，在上面的三类写入方法中，在写入效率方面，按照put、putOrder、putVolatile的顺序效率逐渐降低。 对象实例化 使用 Unsafe 的 allocateInstance 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作： @Data public class A { private int b; public A(){ this.b =1; } } 分别基于构造函数、反射以及 Unsafe 方法的不同方式创建对象进行比较： public void objTest() throws Exception{ A a1=new A(); System.out.println(a1.getB()); A a2 = A.class.newInstance(); System.out.println(a2.getB()); A a3= (A) unsafe.allocateInstance(A.class); System.out.println(a3.getB()); } 打印结果分别为 1、1、0，说明通过allocateInstance方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了Class对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为private类型，将无法通过构造函数和反射创建对象，但allocateInstance方法仍然有效。 典型应用 常规对象实例化方式：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。 非常规的实例化方式：而 Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。 ","date":"2023-02-06","objectID":"/unsafe/:3:3","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"数组操作 介绍 arrayBaseOffset 与 arrayIndexScale 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。 //返回数组中第一个元素的偏移地址 public native int arrayBaseOffset(Class\u003c?\u003e arrayClass); //返回数组中一个元素占用的大小 public native int arrayIndexScale(Class\u003c?\u003e arrayClass); 典型应用 这两个与数据操作相关的方法，在 java.util.concurrent.atomic 包下的 AtomicIntegerArray（可以实现对 Integer 数组中每个元素的原子性操作）中有典型的应用，如下图 AtomicIntegerArray 源码所示，通过 Unsafe 的 arrayBaseOffset 、arrayIndexScale 分别获取数组首元素的偏移地址 base 及单个元素大小因子 scale 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 getAndAdd 方法即通过 checkedByteOffset 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作。 ","date":"2023-02-06","objectID":"/unsafe/:3:4","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"CAS 操作 介绍 这部分主要为 CAS 相关操作的方法。 /** * CAS * @param o 包含要修改field的对象 * @param offset 对象中某field的偏移量 * @param expected 期望值 * @param update 更新值 * @return true | false */ public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object update); public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update); public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update); 什么是 CAS? CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，Unsafe 提供的 CAS 方法（如 compareAndSwapXXX）底层实现即为 CPU 指令 cmpxchg 。 典型应用 在 JUC 包的并发工具类中大量地使用了 CAS 操作，像在前面介绍synchronized和AQS的文章中也多次提到了 CAS，其作为乐观锁在并发工具类中广泛发挥了作用。在 Unsafe 类中，提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作。以compareAndSwapInt方法为例： public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x); 参数中o为需要更新的对象，offset是对象o中整形字段的偏移量，如果这个字段的值与expected相同，则将字段的值设为x这个新值，并且此更新是不可被中断的，也就是一个原子操作。下面是一个使用compareAndSwapInt的例子： private volatile int a; public static void main(String[] args){ CasTest casTest=new CasTest(); new Thread(()-\u003e{ for (int i = 1; i \u003c 5; i++) { casTest.increment(i); System.out.print(casTest.a+\" \"); } }).start(); new Thread(()-\u003e{ for (int i = 5 ; i \u003c10 ; i++) { casTest.increment(i); System.out.print(casTest.a+\" \"); } }).start(); } private void increment(int x){ while (true){ try { long fieldOffset = unsafe.objectFieldOffset(CasTest.class.getDeclaredField(\"a\")); if (unsafe.compareAndSwapInt(this,fieldOffset,x-1,x)) break; } catch (NoSuchFieldException e) { e.printStackTrace(); } } } 运行代码会依次输出： 1 2 3 4 5 6 7 8 9 在上面的例子中，使用两个线程去修改int型属性a的值，并且只有在a的值等于传入的参数x减一时，才会将a的值变为x，也就是实现对a的加一的操作。流程如下所示： 需要注意的是，在调用compareAndSwapInt方法后，会直接返回true或false的修改结果，因此需要我们在代码中手动添加自旋的逻辑。在AtomicInteger类的设计中，也是采用了将compareAndSwapInt的结果作为循环条件，直至修改成功才退出死循环的方式来实现的原子性的自增操作。 ","date":"2023-02-06","objectID":"/unsafe/:3:5","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"线程调度 介绍 Unsafe 类中提供了park、unpark、monitorEnter、monitorExit、tryMonitorEnter方法进行线程调度。 //取消阻塞线程 public native void unpark(Object thread); //阻塞线程 public native void park(boolean isAbsolute, long time); //获得对象锁（可重入锁） @Deprecated public native void monitorEnter(Object o); //释放对象锁 @Deprecated public native void monitorExit(Object o); //尝试获取对象锁 @Deprecated public native boolean tryMonitorEnter(Object o); 方法 park、unpark 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 park 方法实现的，调用 park 方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark 可以终止一个挂起的线程，使其恢复正常。 此外，Unsafe 源码中monitor相关的三个方法已经被标记为deprecated，不建议被使用： //获得对象锁 @Deprecated public native void monitorEnter(Object var1); //释放对象锁 @Deprecated public native void monitorExit(Object var1); //尝试获得对象锁 @Deprecated public native boolean tryMonitorEnter(Object var1); monitorEnter方法用于获得对象锁，monitorExit用于释放对象锁，如果对一个没有被monitorEnter加锁的对象执行此方法，会抛出IllegalMonitorStateException异常。tryMonitorEnter方法尝试获取对象锁，如果成功则返回true，反之返回false。 典型应用 Java 锁和同步器框架的核心类 AbstractQueuedSynchronizer (AQS)，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而 LockSupport 的 park 、unpark 方法实际是调用 Unsafe 的 park 、unpark 方式实现的。 public static void park(Object blocker) { Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, 0L); setBlocker(t, null); } public static void unpark(Thread thread) { if (thread != null) UNSAFE.unpark(thread); } LockSupport 的park方法调用了 Unsafe 的park方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用unpark方法唤醒当前线程。下面的例子对 Unsafe 的这两个方法进行测试： public static void main(String[] args) { Thread mainThread = Thread.currentThread(); new Thread(()-\u003e{ try { TimeUnit.SECONDS.sleep(5); System.out.println(\"subThread try to unpark mainThread\"); unsafe.unpark(mainThread); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); System.out.println(\"park main mainThread\"); unsafe.park(false,0L); System.out.println(\"unpark mainThread success\"); } 程序输出为： park main mainThread subThread try to unpark mainThread unpark mainThread success 程序运行的流程也比较容易看懂，子线程开始运行后先进行睡眠，确保主线程能够调用park方法阻塞自己，子线程在睡眠 5 秒后，调用unpark方法唤醒主线程，使主线程能继续向下执行。整个流程如下图所示： ","date":"2023-02-06","objectID":"/unsafe/:3:6","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"Class 操作 介绍 Unsafe 对Class的相关操作主要包括类加载和静态变量的操作方法。 静态属性读取相关的方法 //获取静态属性的偏移量 public native long staticFieldOffset(Field f); //获取静态属性的对象指针 public native Object staticFieldBase(Field f); //判断类是否需要实例化（用于获取类的静态属性前进行检测） public native boolean shouldBeInitialized(Class\u003c?\u003e c); 创建一个包含静态属性的类，进行测试： @Data public class User { public static String name=\"Hydra\"; int age; } private void staticTest() throws Exception { User user=new User(); System.out.println(unsafe.shouldBeInitialized(User.class)); Field sexField = User.class.getDeclaredField(\"name\"); long fieldOffset = unsafe.staticFieldOffset(sexField); Object fieldBase = unsafe.staticFieldBase(sexField); Object object = unsafe.getObject(fieldBase, fieldOffset); System.out.println(object); } 运行结果： falseHydra 在 Unsafe 的对象操作中，我们学习了通过objectFieldOffset方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用staticFieldOffset方法。在上面的代码中，只有在获取Field对象的过程中依赖到了Class，而获取静态变量的属性时不再依赖于Class。 在上面的代码中首先创建一个User对象，这是因为如果一个类没有被实例化，那么它的静态属性也不会被初始化，最后获取的字段属性将是null。所以在获取静态属性前，需要调用shouldBeInitialized方法，判断在获取前是否需要初始化这个类。如果删除创建 User 对象的语句，运行结果会变为： truenull 使用defineClass方法允许程序在运行时动态地创建一个类 public native Class\u003c?\u003e defineClass(String name, byte[] b, int off, int len, ClassLoader loader,ProtectionDomain protectionDomain); 在实际使用过程中，可以只传入字节数组、起始字节的下标以及读取的字节长度，默认情况下，类加载器（ClassLoader）和保护域（ProtectionDomain）来源于调用此方法的实例。下面的例子中实现了反编译生成后的 class 文件的功能： private static void defineTest() { String fileName=\"F:\\\\workspace\\\\unsafe-test\\\\target\\\\classes\\\\com\\\\cn\\\\model\\\\User.class\"; File file = new File(fileName); try(FileInputStream fis = new FileInputStream(file)) { byte[] content=new byte[(int)file.length()]; fis.read(content); Class clazz = unsafe.defineClass(null, content, 0, content.length, null, null); Object o = clazz.newInstance(); Object age = clazz.getMethod(\"getAge\").invoke(o, null); System.out.println(age); } catch (Exception e) { e.printStackTrace(); } } 在上面的代码中，首先读取了一个class文件并通过文件流将它转化为字节数组，之后使用defineClass方法动态的创建了一个类，并在后续完成了它的实例化工作，流程如下图所示，并且通过这种方式创建的类，会跳过 JVM 的所有安全检查。 除了defineClass方法外，Unsafe 还提供了一个defineAnonymousClass方法： public native Class\u003c?\u003e defineAnonymousClass(Class\u003c?\u003e hostClass, byte[] data, Object[] cpPatches); 使用该方法可以用来动态的创建一个匿名类，在Lambda表达式中就是使用 ASM 动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在 JDK 15 发布的新特性中，在隐藏类（Hidden classes）一条中，指出将在未来的版本中弃用 Unsafe 的defineAnonymousClass方法。 典型应用 Lambda 表达式实现需要依赖 Unsafe 的 defineAnonymousClass 方法定义实现相应的函数式接口的匿名类。 ","date":"2023-02-06","objectID":"/unsafe/:3:7","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"系统信息 介绍 这部分包含两个获取系统相关信息的方法。 //返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。 public native int addressSize(); //内存页的大小，此值为2的幂次方。 public native int pageSize(); 典型应用 这两个方法的应用场景比较少，在java.nio.Bits类中，在使用pageCount计算所需的内存页的数量时，调用了pageSize方法获取内存页的大小。另外，在使用copySwapMemory方法拷贝内存时，调用了addressSize方法，检测 32 位系统的情况。 ","date":"2023-02-06","objectID":"/unsafe/:3:8","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"总结 在本文中，我们首先介绍了 Unsafe 的基本概念、工作原理，并在此基础上，对它的 API 进行了说明与实践。相信大家通过这一过程，能够发现 Unsafe 在某些场景下，确实能够为我们提供编程中的便利。但是回到开头的话题，在使用这些便利时，确实存在着一些安全上的隐患，在我看来，一项技术具有不安全因素并不可怕，可怕的是它在使用过程中被滥用。尽管之前有传言说会在 Java9 中移除 Unsafe 类，不过它还是照样已经存活到了 Java16。按照存在即合理的逻辑，只要使用得当，它还是能给我们带来不少的帮助，因此最后还是建议大家，在使用 Unsafe 的过程中一定要做到使用谨慎使用、避免滥用。 ","date":"2023-02-06","objectID":"/unsafe/:4:0","tags":["java基础"],"title":"Unsafe","uri":"/unsafe/"},{"categories":["基础知识"],"content":"content: 这篇文章介绍了 12 种 Java 中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成 JVM 认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:0:0","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"什么是语法糖？ 语法糖（Syntactic Sugar） 也称糖衣语法，是英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。 我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说 Java 是一个“低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着“高糖”的方向发展。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:1:0","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"Java 中有哪些常见的语法糖？ 前面提到过，语法糖的存在主要是方便开发人员使用。但其实， Java 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。 说到编译，大家肯定都知道，Java 语言中，javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于 Java 虚拟机的字节码。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。 Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。 我们这里会用到反编译 ，你可以通过 Decompilers online 对 Class 文件进行在线反编译。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:0","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"switch 支持 String 与枚举 前面提到过，从 Java 7 开始，Java 语言中的语法糖在逐渐丰富，其中一个比较重要的就是 Java 7 中switch开始支持String。 在开始之前先科普下，Java 中的switch自身原本就支持基本类型。比如int、char等。对于int类型，直接进行数值的比较。对于char类型则是比较其 ascii 码。所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如byte。short，char(ackii 码是整型)以及int。 那么接下来看下switch对String得支持，有以下代码： public class switchDemoString { public static void main(String[] args) { String str = \"world\"; switch (str) { case \"hello\": System.out.println(\"hello\"); break; case \"world\": System.out.println(\"world\"); break; default: break; } } } 反编译后内容如下： public class switchDemoString { public switchDemoString() { } public static void main(String args[]) { String str = \"world\"; String s; switch((s = str).hashCode()) { default: break; case 99162322: if(s.equals(\"hello\")) System.out.println(\"hello\"); break; case 113318802: if(s.equals(\"world\")) System.out.println(\"world\"); break; } } } 看到这个代码，你知道原来 字符串的 switch 是通过equals()和hashCode()方法来实现的。 还好hashCode()方法返回的是int，而不是long。 仔细看下可以发现，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 switch 或者使用纯整数常量，但这也不是很差。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:1","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"泛型 我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式：Code specialization和Code sharing。C++和 C#是使用Code specialization的处理机制，而 Java 使用的是Code sharing的机制。 Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。 也就是说，对于 Java 虚拟机来说，他根本不认识Map\u003cString, String\u003e map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。 类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。 以下代码： Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); map.put(\"name\", \"hollis\"); map.put(\"wechat\", \"Hollis\"); map.put(\"blog\", \"www.hollischuang.com\"); 解语法糖之后会变成： Map map = new HashMap(); map.put(\"name\", \"hollis\"); map.put(\"wechat\", \"Hollis\"); map.put(\"blog\", \"www.hollischuang.com\"); 以下代码： public static \u003cA extends Comparable\u003cA\u003e\u003e A max(Collection\u003cA\u003e xs) { Iterator\u003cA\u003e xi = xs.iterator(); A w = xi.next(); while (xi.hasNext()) { A x = xi.next(); if (w.compareTo(x) \u003c 0) w = x; } return w; } 类型擦除后会变成： public static Comparable max(Collection xs){ Iterator xi = xs.iterator(); Comparable w = (Comparable)xi.next(); while(xi.hasNext()) { Comparable x = (Comparable)xi.next(); if(w.compareTo(x) \u003c 0) w = x; } return w; } 虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。比如并不存在List\u003cString\u003e.class或是List\u003cInteger\u003e.class，而只有List.class。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:2","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"自动装箱与拆箱 自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱，反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型 byte, short, char, int, long, float, double 和 boolean 对应的封装类为 Byte, Short, Character, Integer, Long, Float, Double, Boolean。 先来看个自动装箱的代码： public static void main(String[] args) { int i = 10; Integer n = i; } 反编译后代码如下: public static void main(String args[]) { int i = 10; Integer n = Integer.valueOf(i); } 再来看个自动拆箱的代码： public static void main(String[] args) { Integer i = 10; int n = i; } 反编译后代码如下： public static void main(String args[]) { Integer i = Integer.valueOf(10); int n = i.intValue(); } 从反编译得到内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。 所以，装箱过程是通过调用包装器的 valueOf 方法实现的，而拆箱过程是通过调用包装器的 xxxValue 方法实现的。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:3","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"可变长参数 可变参数(variable arguments)是在 Java 1.5 中引入的一个特性。它允许一个方法把任意数量的值作为参数。 看下以下可变参数代码，其中 print 方法接收可变参数： public static void main(String[] args) { print(\"Holis\", \"公众号:Hollis\", \"博客：www.hollischuang.com\", \"QQ：907607222\"); } public static void print(String... strs) { for (int i = 0; i \u003c strs.length; i++) { System.out.println(strs[i]); } } 反编译后代码： public static void main(String args[]) { print(new String[] { \"Holis\", \"\\u516C\\u4F17\\u53F7:Hollis\", \"\\u535A\\u5BA2\\uFF1Awww.hollischuang.com\", \"QQ\\uFF1A907607222\" }); } public static transient void print(String strs[]) { for(int i = 0; i \u003c strs.length; i++) System.out.println(strs[i]); } 从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:4","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"枚举 Java SE5 提供了一种新的类型-Java 的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。 要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举： public enum t { SPRING,SUMMER; } 然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下： public final class T extends Enum { private T(String s, int i) { super(s, i); } public static T[] values() { T at[]; int i; T at1[]; System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i); return at1; } public static T valueOf(String s) { return (T)Enum.valueOf(demo/T, s); } public static final T SPRING; public static final T SUMMER; private static final T ENUM$VALUES[]; static { SPRING = new T(\"SPRING\", 0); SUMMER = new T(\"SUMMER\", 1); ENUM$VALUES = (new T[] { SPRING, SUMMER }); } } 通过反编译后代码我们可以看到，public final class T extends Enum，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。 当我们使用enum来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:5","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"内部类 内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。 内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，outer.java里面定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件了，分别是outer.class和outer$inner.class。所以内部类的名字完全可以和它的外部类名字相同。 public class OutterClass { private String userName; public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public static void main(String[] args) { } class InnerClass{ private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } } 以上代码编译后会生成两个 class 文件：OutterClass$InnerClass.class 、OutterClass.class 。当我们尝试对OutterClass.class文件进行反编译的时候，命令行会打印以下内容：Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class... Generating OutterClass.jad 。他会把两个文件全部进行反编译，然后一起生成一个OutterClass.jad文件。文件内容如下： public class OutterClass { class InnerClass { public String getName() { return name; } public void setName(String name) { this.name = name; } private String name; final OutterClass this$0; InnerClass() { this.this$0 = OutterClass.this; super(); } } public OutterClass() { } public String getUserName() { return userName; } public void setUserName(String userName){ this.userName = userName; } public static void main(String args1[]) { } private String userName; } ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:6","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"条件编译 —般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。 如在 C 或 CPP 中，可以通过预处理语句来实现条件编译。其实在 Java 中也可实现条件编译。我们先来看一段代码： public class ConditionalCompilation { public static void main(String[] args) { final boolean DEBUG = true; if(DEBUG) { System.out.println(\"Hello, DEBUG!\"); } final boolean ONLINE = false; if(ONLINE){ System.out.println(\"Hello, ONLINE!\"); } } } 反编译后代码如下： public class ConditionalCompilation { public ConditionalCompilation() { } public static void main(String args[]) { boolean DEBUG = true; System.out.println(\"Hello, DEBUG!\"); boolean ONLINE = false; } } 首先，我们发现，在反编译后的代码中没有System.out.println(\"Hello, ONLINE!\");，这其实就是条件编译。当if(ONLINE)为 false 的时候，编译器就没有对其内的代码进行编译。 所以，Java 语法的条件编译，是通过判断条件为常量的 if 语句实现的。其原理也是 Java 语言的语法糖。根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个 Java 类的结构或者类的属性上进行条件编译，这与 C/C++的条件编译相比，确实更有局限性。在 Java 语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:7","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"断言 在 Java 中，assert关键字是从 JAVA SE 1.4 引入的，为了避免和老版本的 Java 代码中使用了assert关键字导致错误，Java 在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关-enableassertions或-ea来开启。 看一段包含断言的代码： public class AssertTest { public static void main(String args[]) { int a = 1; int b = 1; assert a == b; System.out.println(\"公众号：Hollis\"); assert a != b : \"Hollis\"; System.out.println(\"博客：www.hollischuang.com\"); } } 反编译后代码如下： public class AssertTest { public AssertTest() { } public static void main(String args[]) { int a = 1; int b = 1; if(!$assertionsDisabled \u0026\u0026 a != b) throw new AssertionError(); System.out.println(\"\\u516C\\u4F17\\u53F7\\uFF1AHollis\"); if(!$assertionsDisabled \u0026\u0026 a == b) { throw new AssertionError(\"Hollis\"); } else { System.out.println(\"\\u535A\\u5BA2\\uFF1Awww.hollischuang.com\"); return; } } static final boolean $assertionsDisabled = !com/hollis/suguar/AssertTest.desiredAssertionStatus(); } 很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了 assert 这个语法糖我们节省了很多代码。其实断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertError 来打断程序的执行。-enableassertions会设置$assertionsDisabled 字段的值。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:8","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"数值字面量 在 java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。 比如： public class Test { public static void main(String... args) { int i = 10_000; System.out.println(i); } } 反编译后： public class Test { public static void main(String[] args) { int i = 10000; System.out.println(i); } } 反编译后就是把_删除了。也就是说 编译器并不认识在数字字面量中的_，需要在编译阶段把他去掉。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:9","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"for-each 增强 for 循环（for-each）相信大家都不陌生，日常开发经常会用到的，他会比 for 循环要少写很多代码，那么这个语法糖背后是如何实现的呢？ public static void main(String... args) { String[] strs = {\"Hollis\", \"公众号：Hollis\", \"博客：www.hollischuang.com\"}; for (String s : strs) { System.out.println(s); } List\u003cString\u003e strList = ImmutableList.of(\"Hollis\", \"公众号：Hollis\", \"博客：www.hollischuang.com\"); for (String s : strList) { System.out.println(s); } } 反编译后代码如下： public static transient void main(String args[]) { String strs[] = { \"Hollis\", \"\\u516C\\u4F17\\u53F7\\uFF1AHollis\", \"\\u535A\\u5BA2\\uFF1Awww.hollischuang.com\" }; String args1[] = strs; int i = args1.length; for(int j = 0; j \u003c i; j++) { String s = args1[j]; System.out.println(s); } List strList = ImmutableList.of(\"Hollis\", \"\\u516C\\u4F17\\u53F7\\uFF1AHollis\", \"\\u535A\\u5BA2\\uFF1Awww.hollischuang.com\"); String s; for(Iterator iterator = strList.iterator(); iterator.hasNext(); System.out.println(s)) s = (String)iterator.next(); } 代码很简单，for-each 的实现原理其实就是使用了普通的 for 循环和迭代器。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:10","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"try-with-resource Java 里，对于文件操作 IO 流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过 close 方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。 关闭资源的常用方式就是在finally块里是释放，即调用close方法。比如，我们经常会写这样的代码： public static void main(String[] args) { BufferedReader br = null; try { String line; br = new BufferedReader(new FileReader(\"d:\\\\hollischuang.xml\")); while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { // handle exception } finally { try { if (br != null) { br.close(); } } catch (IOException ex) { // handle exception } } } 从 Java 7 开始，jdk 提供了一种更好的方式关闭资源，使用try-with-resources语句，改写一下上面的代码，效果如下： public static void main(String... args) { try (BufferedReader br = new BufferedReader(new FileReader(\"d:\\\\ hollischuang.xml\"))) { String line; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { // handle exception } } 看，这简直是一大福音啊，虽然我之前一般使用IOUtils去关闭流，并不会使用在finally中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后： public static transient void main(String args[]) { BufferedReader br; Throwable throwable; br = new BufferedReader(new FileReader(\"d:\\\\ hollischuang.xml\")); throwable = null; String line; try { while((line = br.readLine()) != null) System.out.println(line); } catch(Throwable throwable2) { throwable = throwable2; throw throwable2; } if(br != null) if(throwable != null) try { br.close(); } catch(Throwable throwable1) { throwable.addSuppressed(throwable1); } else br.close(); break MISSING_BLOCK_LABEL_113; Exception exception; exception; if(br != null) if(throwable != null) try { br.close(); } catch(Throwable throwable3) { throwable.addSuppressed(throwable3); } else br.close(); throw exception; IOException ioexception; ioexception; } } 其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:11","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"Lambda 表达式 关于 lambda 表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。Labmda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。 先来看一个简单的 lambda 表达式。遍历一个 list： public static void main(String... args) { List\u003cString\u003e strList = ImmutableList.of(\"Hollis\", \"公众号：Hollis\", \"博客：www.hollischuang.com\"); strList.forEach( s -\u003e { System.out.println(s); } ); } 为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件。 反编译后代码如下: public static /* varargs */ void main(String ... args) { ImmutableList strList = ImmutableList.of((Object)\"Hollis\", (Object)\"\\u516c\\u4f17\\u53f7\\uff1aHollis\", (Object)\"\\u535a\\u5ba2\\uff1awww.hollischuang.com\"); strList.forEach((Consumer\u003cString\u003e)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)()); } private static /* synthetic */ void lambda$main$0(String s) { System.out.println(s); } 可以看到，在forEach方法中，其实是调用了java.lang.invoke.LambdaMetafactory#metafactory方法，该方法的第四个参数 implMethod 指定了方法实现。可以看到这里其实是调用了一个lambda$main$0方法进行了输出。 再来看一个稍微复杂一点的，先对 List 进行过滤，然后再输出： public static void main(String... args) { List\u003cString\u003e strList = ImmutableList.of(\"Hollis\", \"公众号：Hollis\", \"博客：www.hollischuang.com\"); List HollisList = strList.stream().filter(string -\u003e string.contains(\"Hollis\")).collect(Collectors.toList()); HollisList.forEach( s -\u003e { System.out.println(s); } ); } 反编译后代码如下： public static /* varargs */ void main(String ... args) { ImmutableList strList = ImmutableList.of((Object)\"Hollis\", (Object)\"\\u516c\\u4f17\\u53f7\\uff1aHollis\", (Object)\"\\u535a\\u5ba2\\uff1awww.hollischuang.com\"); List\u003cObject\u003e HollisList = strList.stream().filter((Predicate\u003cString\u003e)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)Z, lambda$main$0(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList()); HollisList.forEach((Consumer\u003cObject\u003e)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$1(java.lang.Object ), (Ljava/lang/Object;)V)()); } private static /* synthetic */ void lambda$main$1(Object s) { System.out.println(s); } private static /* synthetic */ boolean lambda$main$0(String string) { return string.contains(\"Hollis\"); } 两个 lambda 表达式分别调用了lambda$main$1和lambda$main$0两个方法。 所以，lambda 表达式的实现其实是依赖了一些底层的 api，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 api 的方式。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:2:12","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"可能遇到的坑 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:3:0","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"泛型 一、当泛型遇到重载 public class GenericTypes { public static void method(List\u003cString\u003e list) { System.out.println(\"invoke method(List\u003cString\u003e list)\"); } public static void method(List\u003cInteger\u003e list) { System.out.println(\"invoke method(List\u003cInteger\u003e list)\"); } } 上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List\u003cString\u003e另一个是List\u003cInteger\u003e ，但是，这段代码是编译通不过的。因为我们前面讲过，参数List\u003cInteger\u003e和List\u003cString\u003e编译之后都被擦除了，变成了一样的原生类型 List，擦除动作导致这两个方法的特征签名变得一模一样。 二、当泛型遇到 catch 泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由 JVM 在运行时刻来进行的。由于类型信息被擦除，JVM 是无法区分两个异常类型MyException\u003cString\u003e和MyException\u003cInteger\u003e的 三、当泛型内包含静态变量 public class StaticTest{ public static void main(String[] args){ GT\u003cInteger\u003e gti = new GT\u003cInteger\u003e(); gti.var=1; GT\u003cString\u003e gts = new GT\u003cString\u003e(); gts.var=2; System.out.println(gti.var); } } class GT\u003cT\u003e{ public static int var=0; public void nothing(T x){} } 以上代码输出结果为：2！ 由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:3:1","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"自动装箱与拆箱 对象相等比较 public static void main(String[] args) { Integer a = 1000; Integer b = 1000; Integer c = 100; Integer d = 100; System.out.println(\"a == b is \" + (a == b)); System.out.println((\"c == d is \" + (c == d))); } 输出结果： a == b is false c == d is true 在 Java 5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。 适用于整数值区间-128 至 +127。 只适用于自动装箱。使用构造函数创建对象不适用。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:3:2","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"增强 for 循环 for (Student stu : students) { if (stu.getId() == 2) students.remove(stu); } 会抛出ConcurrentModificationException异常。 Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出java.util.ConcurrentModificationException异常。 所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法remove()来删除对象，Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:3:3","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"总结 前面介绍了 12 种 Java 中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成 JVM 认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。 有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避过度使用。使用之前最好了解下原理，避免掉坑。 ","date":"2023-02-06","objectID":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/:4:0","tags":["java基础"],"title":"Java语法糖","uri":"/java%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"categories":["基础知识"],"content":"何为反射？ 如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。 反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。 通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。 ","date":"2023-02-06","objectID":"/%E5%8F%8D%E5%B0%84/:1:0","tags":["java基础"],"title":"反射机制","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["基础知识"],"content":"反射的应用场景了解么？ 像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。 但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。 这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。 比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 Method 来调用指定的方法。 public class DebugInvocationHandler implements InvocationHandler { /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { System.out.println(\"before method \" + method.getName()); Object result = method.invoke(target, args); System.out.println(\"after method \" + method.getName()); return result; } } 另外，像 Java 中的一大利器 注解 的实现也用到了反射。 为什么你使用 Spring 的时候 ，一个@Component注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？ 这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。 ","date":"2023-02-06","objectID":"/%E5%8F%8D%E5%B0%84/:2:0","tags":["java基础"],"title":"反射机制","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["基础知识"],"content":"谈谈反射机制的优缺点 优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利 缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：Java Reflection: Why is it so slow? ","date":"2023-02-06","objectID":"/%E5%8F%8D%E5%B0%84/:3:0","tags":["java基础"],"title":"反射机制","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["基础知识"],"content":"反射实战 ","date":"2023-02-06","objectID":"/%E5%8F%8D%E5%B0%84/:4:0","tags":["java基础"],"title":"反射机制","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["基础知识"],"content":"获取 Class 对象的四种方式 如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象: 1. 知道具体类的情况下可以使用： Class alunbarClass = TargetObject.class; 但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化 2. 通过 Class.forName()传入类的全路径获取： Class alunbarClass1 = Class.forName(\"cn.javaguide.TargetObject\"); 3. 通过对象实例instance.getClass()获取： TargetObject o = new TargetObject(); Class alunbarClass2 = o.getClass(); 4. 通过类加载器xxxClassLoader.loadClass()传入类路径获取: ClassLoader.getSystemClassLoader().loadClass(\"cn.javaguide.TargetObject\"); 通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行 ","date":"2023-02-06","objectID":"/%E5%8F%8D%E5%B0%84/:4:1","tags":["java基础"],"title":"反射机制","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["基础知识"],"content":"反射的一些基本操作 创建一个我们要使用反射操作的类 TargetObject。 package cn.javaguide; public class TargetObject { private String value; public TargetObject() { value = \"JavaGuide\"; } public void publicMethod(String s) { System.out.println(\"I love \" + s); } private void privateMethod() { System.out.println(\"value is \" + value); } } 使用反射操作这个类的方法以及参数 package cn.javaguide; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException { /** * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例 */ Class\u003c?\u003e targetClass = Class.forName(\"cn.javaguide.TargetObject\"); TargetObject targetObject = (TargetObject) targetClass.newInstance(); /** * 获取 TargetObject 类中定义的所有方法 */ Method[] methods = targetClass.getDeclaredMethods(); for (Method method : methods) { System.out.println(method.getName()); } /** * 获取指定方法并调用 */ Method publicMethod = targetClass.getDeclaredMethod(\"publicMethod\", String.class); publicMethod.invoke(targetObject, \"JavaGuide\"); /** * 获取指定参数并对参数进行修改 */ Field field = targetClass.getDeclaredField(\"value\"); //为了对类中的参数进行修改我们取消安全检查 field.setAccessible(true); field.set(targetObject, \"JavaGuide\"); /** * 调用 private 方法 */ Method privateMethod = targetClass.getDeclaredMethod(\"privateMethod\"); //为了调用private方法我们取消安全检查 privateMethod.setAccessible(true); privateMethod.invoke(targetObject); } } 输出内容： publicMethod privateMethod I love JavaGuide value is JavaGuide 注意 : 有读者提到上面代码运行会抛出 ClassNotFoundException 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 TargetObject 所在的包 。 Class\u003c?\u003e targetClass = Class.forName(\"cn.javaguide.TargetObject\"); ","date":"2023-02-06","objectID":"/%E5%8F%8D%E5%B0%84/:4:2","tags":["java基础"],"title":"反射机制","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["基础知识"],"content":"什么是序列化和反序列化? 如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。 简单来说： 序列化： 将数据结构或对象转换成二进制字节流的过程 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程 对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。 下面是序列化和反序列化常见应用场景： 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化； 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化； 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化； 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。 维基百科是如是介绍序列化的： 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。 综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。 序列化协议对应于 TCP/IP 4 层模型的哪一层？ 我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？ 应用层 传输层 网络层 网络接口层 如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？ 因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。 ","date":"2023-02-06","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:1:0","tags":["java基础"],"title":"序列化和反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["基础知识"],"content":"常见序列化协议有哪些？ JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。 像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。 ","date":"2023-02-06","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:0","tags":["java基础"],"title":"序列化和反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["基础知识"],"content":"JDK 自带的序列化方式 JDK 自带的序列化，只需实现 java.io.Serializable接口即可。 @AllArgsConstructor @NoArgsConstructor @Getter @Builder @ToString public class RpcRequest implements Serializable { private static final long serialVersionUID = 1905122041950251207L; private String requestId; private String interfaceName; private String methodName; private Object[] parameters; private Class\u003c?\u003e[] paramTypes; private RpcMessageTypeEnum rpcMessageTypeEnum; } serialVersionUID 有什么作用？ 序列化号 serialVersionUID 属于版本控制的作用。反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID。 serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？ static 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。 static 变量是属于类的而不是对象。你反序列之后，static 变量的值就像是默认赋予给了对象一样，看着就像是 static 变量被序列化，实际只是假象罢了。 如果有些字段不想进行序列化怎么办？ 对于不想进行序列化的变量，可以使用 transient 关键字修饰。 transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。 关于 transient 还有几点注意： transient 只能修饰变量，不能修饰类和方法。 transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。 static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。 为什么不推荐使用 JDK 自带的序列化？ 我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因： 不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。 性能差 ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。 存在安全问题 ：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：应用安全:JAVA反序列化漏洞之殇 - Cryin 、Java反序列化安全漏洞怎么回事? - Monica 。 ","date":"2023-02-06","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:1","tags":["java基础"],"title":"序列化和反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["基础知识"],"content":"Kryo Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。 另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。 guide-rpc-framework 就是使用的 kryo 进行序列化，序列化和反序列化相关的代码如下： /** * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language * * @author shuang.kou * @createTime 2020年05月13日 19:29:00 */ @Slf4j public class KryoSerializer implements Serializer { /** * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects */ private final ThreadLocal\u003cKryo\u003e kryoThreadLocal = ThreadLocal.withInitial(() -\u003e { Kryo kryo = new Kryo(); kryo.register(RpcResponse.class); kryo.register(RpcRequest.class); return kryo; }); @Override public byte[] serialize(Object obj) { try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Output output = new Output(byteArrayOutputStream)) { Kryo kryo = kryoThreadLocal.get(); // Object-\u003ebyte:将对象序列化为byte数组 kryo.writeObject(output, obj); kryoThreadLocal.remove(); return output.toBytes(); } catch (Exception e) { throw new SerializeException(\"Serialization failed\"); } } @Override public \u003cT\u003e T deserialize(byte[] bytes, Class\u003cT\u003e clazz) { try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); Input input = new Input(byteArrayInputStream)) { Kryo kryo = kryoThreadLocal.get(); // byte-\u003eObject:从byte数组中反序列化出对象 Object o = kryo.readObject(input, clazz); kryoThreadLocal.remove(); return clazz.cast(o); } catch (Exception e) { throw new SerializeException(\"Deserialization failed\"); } } } Github 地址：https://github.com/EsotericSoftware/kryo 。 ","date":"2023-02-06","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:2","tags":["java基础"],"title":"序列化和反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["基础知识"],"content":"Protobuf Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。 Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言 一个简单的 proto 文件如下： // protobuf的版本 syntax = \"proto3\"; // SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct message Person { //string类型字段 string name = 1; // int 类型字段 int32 age = 2; } Github 地址：https://github.com/protocolbuffers/protobuf 。 ","date":"2023-02-06","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:3","tags":["java基础"],"title":"序列化和反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["基础知识"],"content":"ProtoStuff 由于 Protobuf 的易用性，它的哥哥 Protostuff 诞生了。 protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。 Github 地址：https://github.com/protostuff/protostuff 。 ","date":"2023-02-06","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:4","tags":["java基础"],"title":"序列化和反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["基础知识"],"content":"Hessian Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。 Dubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。 ","date":"2023-02-06","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:5","tags":["java基础"],"title":"序列化和反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["基础知识"],"content":"总结 Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。 像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。 除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。 ","date":"2023-02-06","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:6","tags":["java基础"],"title":"序列化和反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["基础知识"],"content":"final 关键字 final 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点： final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法； final 修饰的方法不能被重写； final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。 说明：使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。 ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:1:0","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"static 关键字 static 关键字主要有以下四种使用场景： 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名() 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—\u003e非静态代码块—\u003e构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态内部类（static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。 静态导包(用来导入类中的静态资源，1.5 之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:2:0","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"this 关键字 this 关键字用于引用类的当前实例。 例如： class Manager { Employees[] employees; void manageEmployees() { int totalEmp = this.employees.length; System.out.println(\"Total employees: \" + totalEmp); this.report(); } void report() { } } 在上面的示例中，this 关键字用于两个地方： this.employees.length：访问类 Manager 的当前实例的变量。 this.report（）：调用类 Manager 的当前实例的方法。 此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。 ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:3:0","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"super 关键字 super 关键字用于从子类访问父类的变量和方法。 例如： public class Super { protected int number; protected showNumber() { System.out.println(\"number = \" + number); } } public class Sub extends Super { void bar() { super.number = 10; super.showNumber(); } } 在上面的例子中，Sub 类访问父类成员变量 number 并调用其父类 Super 的 showNumber（） 方法。 使用 this 和 super 要注意的问题： 在构造器中使用 super() 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super 不能用在 static 方法中。 简单解释一下： 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this 和 super 是属于对象范畴的东西，而静态方法是属于类范畴的东西。 ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:4:0","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"static 关键字详解 static 关键字主要有以下四种使用场景 修饰成员变量和成员方法 静态代码块 修饰类(只能修饰内部类) 静态导包(用来导入类中的静态资源，1.5 之后的新特性) ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:5:0","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"修饰成员变量和成员方法(常用) 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。 调用格式： 类名.静态变量名 类名.静态方法名() 如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。 测试方法： public class StaticBean { String name; //静态变量 static int age; public StaticBean(String name) { this.name = name; } //静态方法 static void sayHello() { System.out.println(\"Hello i am java\"); } @Override public String toString() { return \"StaticBean{\"+ \"name=\" + name + \",age=\" + age + \"}\"; } } public class StaticDemo { public static void main(String[] args) { StaticBean staticBean = new StaticBean(\"1\"); StaticBean staticBean2 = new StaticBean(\"2\"); StaticBean staticBean3 = new StaticBean(\"3\"); StaticBean staticBean4 = new StaticBean(\"4\"); StaticBean.age = 33; System.out.println(staticBean + \" \" + staticBean2 + \" \" + staticBean3 + \" \" + staticBean4); //StaticBean{name=1,age=33} StaticBean{name=2,age=33} StaticBean{name=3,age=33} StaticBean{name=4,age=33} StaticBean.sayHello();//Hello i am java } } ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:5:1","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"静态代码块 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块 —\u003e 非静态代码块 —\u003e 构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态代码块的格式是 static { 语句体; } 一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM 加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM 将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问. ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:5:2","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"静态内部类 静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖外围类的创建。 它不能使用任何外围类的非 static 成员变量和方法。 Example（静态内部类实现单例模式） public class Singleton { //声明为 private 避免调用默认构造方法创建对象 private Singleton() { } // 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问 private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getUniqueInstance() { return SingletonHolder.INSTANCE; } } 当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance()方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。 ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:5:3","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"静态导包 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法 //将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用 //如果只想导入单一某个静态方法，只需要将*换成对应的方法名即可 import static java.lang.Math.*;//换成import static java.lang.Math.max;具有一样的效果 public class Demo { public static void main(String[] args) { int max = max(1,2); System.out.println(max); } } ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:5:4","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"补充内容 ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:6:0","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"静态方法与非静态方法 静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。 Example class Foo { int i; public Foo(int i) { this.i = i; } public static String method1() { return \"An example string that doesn't depend on i (an instance variable)\"; } public int method2() { return this.i + 1; //Depends on i } } 你可以像这样调用静态方法：Foo.method1()。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行 Foo bar = new Foo(1); bar.method2(); 总结： 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:6:1","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"static{}静态代码块与{}非静态代码块(构造代码块) 相同点： 都是在 JVM 加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些 static 变量进行赋值。 不同点： 静态代码块在非静态代码块之前执行(静态代码块 -\u003e 非静态代码块 -\u003e 构造方法)。静态代码块只在第一次 new 执行一次，之后不再执行，而非静态代码块在每 new 一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 🐛 修正（参见： issue ##677 ） ：静态代码块可能在第一次 new 对象的时候执行，但不一定只在第一次 new 的时候执行。比如通过 Class.forName(\"ClassDemo\")创建 Class 对象的时候也会执行，即 new 或者 Class.forName(\"ClassDemo\") 都会执行静态代码块。 一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays 类，Character 类，String 类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的. Example： public class Test { public Test() { System.out.print(\"默认构造方法！--\"); } //非静态代码块 { System.out.print(\"非静态代码块！--\"); } //静态代码块 static { System.out.print(\"静态代码块！--\"); } private static void test() { System.out.print(\"静态方法中的内容! --\"); { System.out.print(\"静态方法中的代码块！--\"); } } public static void main(String[] args) { Test test = new Test(); Test.test();//静态代码块！--静态方法中的内容! --静态方法中的代码块！-- } } 上述代码输出： 静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！-- 当只执行 Test.test(); 时输出： 静态代码块！--静态方法中的内容! --静态方法中的代码块！-- 当只执行 Test test = new Test(); 时输出： 静态代码块！--非静态代码块！--默认构造方法！-- 非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 ","date":"2023-02-06","objectID":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/:6:2","tags":["java基础"],"title":"权限修饰符","uri":"/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"categories":["基础知识"],"content":"《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 BigDecimal 来进行浮点数的运算”。 浮点数的运算竟然还会有精度丢失的风险吗？确实会！ 示例代码： float a = 2.0f - 1.9f; float b = 1.8f - 1.7f; System.out.println(a);// 0.100000024 System.out.println(b);// 0.099999905 System.out.println(a == b);// false 为什么浮点数 float 或 double 运算的时候会有精度丢失的风险呢？ 这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。 就比如说十进制下的 0.2 就没办法精确转换成二进制小数： // 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止， // 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。 0.2 * 2 = 0.4 -\u003e 0 0.4 * 2 = 0.8 -\u003e 0 0.8 * 2 = 1.6 -\u003e 1 0.6 * 2 = 1.2 -\u003e 1 0.2 * 2 = 0.4 -\u003e 0（发生循环） ... 关于浮点数的更多内容，建议看一下计算机系统基础（四）浮点数 这篇文章。 ","date":"2023-02-06","objectID":"/bigdecimal/:0:0","tags":["java基础"],"title":"Bigdecimal","uri":"/bigdecimal/"},{"categories":["基础知识"],"content":"BigDecimal 介绍 BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。 通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。 《阿里巴巴 Java 开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。 具体原因我们在上面已经详细介绍了，这里就不多提了。 想要解决浮点数运算精度丢失这个问题，可以直接使用 BigDecimal 来定义浮点数的值，然后再进行浮点数的运算操作即可。 BigDecimal a = new BigDecimal(\"1.0\"); BigDecimal b = new BigDecimal(\"0.9\"); BigDecimal c = new BigDecimal(\"0.8\"); BigDecimal x = a.subtract(b); BigDecimal y = b.subtract(c); System.out.println(x.compareTo(y));// 0 ","date":"2023-02-06","objectID":"/bigdecimal/:1:0","tags":["java基础"],"title":"Bigdecimal","uri":"/bigdecimal/"},{"categories":["基础知识"],"content":"BigDecimal 常见方法 ","date":"2023-02-06","objectID":"/bigdecimal/:2:0","tags":["java基础"],"title":"Bigdecimal","uri":"/bigdecimal/"},{"categories":["基础知识"],"content":"创建 我们在使用 BigDecimal 时，为了防止精度丢失，推荐使用它的BigDecimal(String val)构造方法或者 BigDecimal.valueOf(double val) 静态方法来创建对象。 《阿里巴巴 Java 开发手册》对这部分内容也有提到，如下图所示。 ","date":"2023-02-06","objectID":"/bigdecimal/:2:1","tags":["java基础"],"title":"Bigdecimal","uri":"/bigdecimal/"},{"categories":["基础知识"],"content":"加减乘除 add 方法用于将两个 BigDecimal 对象相加，subtract 方法用于将两个 BigDecimal 对象相减。multiply 方法用于将两个 BigDecimal 对象相乘，divide 方法用于将两个 BigDecimal 对象相除。 BigDecimal a = new BigDecimal(\"1.0\"); BigDecimal b = new BigDecimal(\"0.9\"); System.out.println(a.add(b));// 1.9 System.out.println(a.subtract(b));// 0.1 System.out.println(a.multiply(b));// 0.90 System.out.println(a.divide(b));// 无法除尽，抛出 ArithmeticException 异常 System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11 这里需要注意的是，在我们使用 divide 方法的时候尽量使用 3 个参数版本，并且RoundingMode 不要选择 UNNECESSARY，否则很可能会遇到 ArithmeticException（无法除尽出现无限循环小数的时候），其中 scale 表示要保留几位小数，roundingMode 代表保留规则。 public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) { return divide(divisor, scale, roundingMode.oldMode); } 保留规则非常多，这里列举几种: public enum RoundingMode { // 2.5 -\u003e 3 , 1.6 -\u003e 2 // -1.6 -\u003e -2 , -2.5 -\u003e -3 UP(BigDecimal.ROUND_UP), // 2.5 -\u003e 2 , 1.6 -\u003e 1 // -1.6 -\u003e -1 , -2.5 -\u003e -2 DOWN(BigDecimal.ROUND_DOWN), // 2.5 -\u003e 3 , 1.6 -\u003e 2 // -1.6 -\u003e -1 , -2.5 -\u003e -2 CEILING(BigDecimal.ROUND_CEILING), // 2.5 -\u003e 2 , 1.6 -\u003e 1 // -1.6 -\u003e -2 , -2.5 -\u003e -3 FLOOR(BigDecimal.ROUND_FLOOR), // 2.5 -\u003e 3 , 1.6 -\u003e 2 // -1.6 -\u003e -2 , -2.5 -\u003e -3 HALF_UP(BigDecimal.ROUND_HALF_UP), //...... } ","date":"2023-02-06","objectID":"/bigdecimal/:2:2","tags":["java基础"],"title":"Bigdecimal","uri":"/bigdecimal/"},{"categories":["基础知识"],"content":"大小比较 a.compareTo(b) : 返回 -1 表示 a 小于 b，0 表示 a 等于 b ， 1 表示 a 大于 b。 BigDecimal a = new BigDecimal(\"1.0\"); BigDecimal b = new BigDecimal(\"0.9\"); System.out.println(a.compareTo(b));// 1 ","date":"2023-02-06","objectID":"/bigdecimal/:2:3","tags":["java基础"],"title":"Bigdecimal","uri":"/bigdecimal/"},{"categories":["基础知识"],"content":"保留几位小数 通过 setScale方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA 会提示。 BigDecimal m = new BigDecimal(\"1.255433\"); BigDecimal n = m.setScale(3,RoundingMode.HALF_DOWN); System.out.println(n);// 1.255 ","date":"2023-02-06","objectID":"/bigdecimal/:2:4","tags":["java基础"],"title":"Bigdecimal","uri":"/bigdecimal/"},{"categories":["基础知识"],"content":"BigDecimal 等值比较问题 《阿里巴巴 Java 开发手册》中提到： BigDecimal 使用 equals() 方法进行等值比较出现问题的代码示例： BigDecimal a = new BigDecimal(\"1\"); BigDecimal b = new BigDecimal(\"1.0\"); System.out.println(a.equals(b));//false 这是因为 equals() 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 compareTo() 方法比较的时候会忽略精度。 1.0 的 scale 是 1，1 的 scale 是 0，因此 a.equals(b) 的结果是 false。 compareTo() 方法可以比较两个 BigDecimal 的值，如果相等就返回 0，如果第 1 个数比第 2 个数大则返回 1，反之返回-1。 BigDecimal a = new BigDecimal(\"1\"); BigDecimal b = new BigDecimal(\"1.0\"); System.out.println(a.compareTo(b));//0 ","date":"2023-02-06","objectID":"/bigdecimal/:3:0","tags":["java基础"],"title":"Bigdecimal","uri":"/bigdecimal/"},{"categories":["基础知识"],"content":"BigDecimal 工具类分享 网上有一个使用人数比较多的 BigDecimal 工具类，提供了多个静态方法来简化 BigDecimal 的操作。 我对其进行了简单改进，分享一下源码： import java.math.BigDecimal; import java.math.RoundingMode; /** * 简化BigDecimal计算的小工具类 */ public class BigDecimalUtil { /** * 默认除法运算精度 */ private static final int DEF_DIV_SCALE = 10; private BigDecimalUtil() { } /** * 提供精确的加法运算。 * * @param v1 被加数 * @param v2 加数 * @return 两个参数的和 */ public static double add(double v1, double v2) { BigDecimal b1 = BigDecimal.valueOf(v1); BigDecimal b2 = BigDecimal.valueOf(v2); return b1.add(b2).doubleValue(); } /** * 提供精确的减法运算。 * * @param v1 被减数 * @param v2 减数 * @return 两个参数的差 */ public static double subtract(double v1, double v2) { BigDecimal b1 = BigDecimal.valueOf(v1); BigDecimal b2 = BigDecimal.valueOf(v2); return b1.subtract(b2).doubleValue(); } /** * 提供精确的乘法运算。 * * @param v1 被乘数 * @param v2 乘数 * @return 两个参数的积 */ public static double multiply(double v1, double v2) { BigDecimal b1 = BigDecimal.valueOf(v1); BigDecimal b2 = BigDecimal.valueOf(v2); return b1.multiply(b2).doubleValue(); } /** * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到 * 小数点以后10位，以后的数字四舍五入。 * * @param v1 被除数 * @param v2 除数 * @return 两个参数的商 */ public static double divide(double v1, double v2) { return divide(v1, v2, DEF_DIV_SCALE); } /** * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指 * 定精度，以后的数字四舍五入。 * * @param v1 被除数 * @param v2 除数 * @param scale 表示表示需要精确到小数点以后几位。 * @return 两个参数的商 */ public static double divide(double v1, double v2, int scale) { if (scale \u003c 0) { throw new IllegalArgumentException( \"The scale must be a positive integer or zero\"); } BigDecimal b1 = BigDecimal.valueOf(v1); BigDecimal b2 = BigDecimal.valueOf(v2); return b1.divide(b2, scale, RoundingMode.HALF_UP).doubleValue(); } /** * 提供精确的小数位四舍五入处理。 * * @param v 需要四舍五入的数字 * @param scale 小数点后保留几位 * @return 四舍五入后的结果 */ public static double round(double v, int scale) { if (scale \u003c 0) { throw new IllegalArgumentException( \"The scale must be a positive integer or zero\"); } BigDecimal b = BigDecimal.valueOf(v); BigDecimal one = new BigDecimal(\"1\"); return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue(); } /** * 提供精确的类型转换(Float) * * @param v 需要被转换的数字 * @return 返回转换结果 */ public static float convertToFloat(double v) { BigDecimal b = new BigDecimal(v); return b.floatValue(); } /** * 提供精确的类型转换(Int)不进行四舍五入 * * @param v 需要被转换的数字 * @return 返回转换结果 */ public static int convertsToInt(double v) { BigDecimal b = new BigDecimal(v); return b.intValue(); } /** * 提供精确的类型转换(Long) * * @param v 需要被转换的数字 * @return 返回转换结果 */ public static long convertsToLong(double v) { BigDecimal b = new BigDecimal(v); return b.longValue(); } /** * 返回两个数中大的一个值 * * @param v1 需要被对比的第一个数 * @param v2 需要被对比的第二个数 * @return 返回两个数中大的一个值 */ public static double returnMax(double v1, double v2) { BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v2); return b1.max(b2).doubleValue(); } /** * 返回两个数中小的一个值 * * @param v1 需要被对比的第一个数 * @param v2 需要被对比的第二个数 * @return 返回两个数中小的一个值 */ public static double returnMin(double v1, double v2) { BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v2); return b1.min(b2).doubleValue(); } /** * 精确对比两个数字 * * @param v1 需要被对比的第一个数 * @param v2 需要被对比的第二个数 * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1 */ public static int compareTo(double v1, double v2) { BigDecimal b1 = BigDecimal.valueOf(v1); BigDecimal b2 = BigDecimal.valueOf(v2); return b1.compareTo(b2); } } ","date":"2023-02-06","objectID":"/bigdecimal/:4:0","tags":["java基础"],"title":"Bigdecimal","uri":"/bigdecimal/"},{"categories":["基础知识"],"content":"总结 浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。 不过，Java 提供了BigDecimal 来操作浮点数。BigDecimal 的实现利用到了 BigInteger （用来操作大整数）, 所不同的是 BigDecimal 加入了小数位的概念。 ","date":"2023-02-06","objectID":"/bigdecimal/:5:0","tags":["java基础"],"title":"Bigdecimal","uri":"/bigdecimal/"},{"categories":["中间件"],"content":"使用之前需要掌握： 拥有 Java 开发环境以及相应 IDE 熟悉 Spring Boot 熟悉 Maven ","date":"2023-02-02","objectID":"/mybatis-plus-start/:0:0","tags":["MyBatis-Plus"],"title":"MyBatis-Plus初级运用","uri":"/mybatis-plus-start/"},{"categories":["中间件"],"content":"1.数据表准备 以User表为例 id name age email 1 Jone 18 test1@baomidou.com 2 Jack 20 test2@baomidou.com 3 Tom 28 test3@baomidou.com 4 Sandy 21 test4@baomidou.com 5 Billie 24 test5@baomidou.com 其数据库DDL脚本如下： DROP TABLE IF EXISTS user; CREATE TABLE user ( id BIGINT(20) NOT NULL COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); 其插入数据脚本如下： DELETE FROM user; INSERT INTO user (id, name, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.com'), (2, 'Jack', 20, 'test2@baomidou.com'), (3, 'Tom', 28, 'test3@baomidou.com'), (4, 'Sandy', 21, 'test4@baomidou.com'), (5, 'Billie', 24, 'test5@baomidou.com'); ","date":"2023-02-02","objectID":"/mybatis-plus-start/:1:0","tags":["MyBatis-Plus"],"title":"MyBatis-Plus初级运用","uri":"/mybatis-plus-start/"},{"categories":["中间件"],"content":"2.框架搭建 使用 Spring Initializer (opens new window) 快速初始化一个 Spring Boot 工程 添加依赖 mybatis-plus支持MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift，此处只使用h2举例 \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e最新版本\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e 配置application.yaml # DataSource Config spring: datasource: driver-class-name: org.h2.Driver schema: classpath:db/schema-h2.sql username: root password: test sql: init: schema-locations: classpath:db/schema-h2.sql data-locations: classpath:db/data-h2.sql ","date":"2023-02-02","objectID":"/mybatis-plus-start/:1:1","tags":["MyBatis-Plus"],"title":"MyBatis-Plus初级运用","uri":"/mybatis-plus-start/"},{"categories":["中间件"],"content":"3.编码 编写实体类 User.java（此处使用了 Lombok 简化代码） @Data public class User { private Long id; private String name; private Integer age; private String email; } 编写 Mapper 包下的 UserMapper接口 public interface UserMapper extends BaseMapper\u003cUser\u003e { } ","date":"2023-02-02","objectID":"/mybatis-plus-start/:1:2","tags":["MyBatis-Plus"],"title":"MyBatis-Plus初级运用","uri":"/mybatis-plus-start/"},{"categories":["中间件"],"content":"4.开始使用 添加测试类，进行功能测试： @SpringBootTest public class SampleTest { @Autowired private UserMapper userMapper; @Test public void testSelect() { System.out.println((\"----- selectAll method test ------\")); //UserMapper 中的 selectList() //方法的参数为 MP 内置的条件封装器 Wrapper，所以不填写就是无任何条件 List\u003cUser\u003e userList = userMapper.selectList(null); Assert.assertEquals(5, userList.size()); userList.forEach(System.out::println); } } 控制台输出： User(id=1, name=Jone, age=18, email=test1@baomidou.com) User(id=2, name=Jack, age=20, email=test2@baomidou.com) User(id=3, name=Tom, age=28, email=test3@baomidou.com) User(id=4, name=Sandy, age=21, email=test4@baomidou.com) User(id=5, name=Billie, age=24, email=test5@baomidou.com) ","date":"2023-02-02","objectID":"/mybatis-plus-start/:1:3","tags":["MyBatis-Plus"],"title":"MyBatis-Plus初级运用","uri":"/mybatis-plus-start/"}]